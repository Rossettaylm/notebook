# 链接

date：2022年05月12日

------------

> 链接是一个将各种代码和数据片段收集并组合成一个单一文件的过程

## 1. 链接的定义

链接的执行时间：

- compile 编译时
- loader 加载时，程序被加载器加载到内存中
- run 运行时，由应用程序来执行

```shell
cpp main.c /tmp/main.i #预处理
	
cc1 /tmp/main.i -Og -o /tmp/main.s	#编译

as -o /tmp/main.o /tmp/main.s 	#汇编

...同样的过程得到sum.o

ld -o prog main.o sum.o 	#链接

./prog	#通过加载器程序将prog加载到主存中运行
```

为了构造可执行文件，链接器ld必须完成两个任务：

- **符号解析**，每个符号代表了一个函数、全局变量或静态变量
- **重定位**，编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而定位这些节，然后修改所有对这些目标的引用，使得它们指向这个内存位置。确定代码和数据节的运行时位置

## 2. 目标文件

- 可重定位目标文件
- 可执行目标文件
- 共享目标文件——可以在加载或者运行时被动态的加载进内存并链接

不同操作系统的目标文件格式不同，现代x86-64的Windows和Linux系统使用可执行可链接格式（Executable and Linkable Format，ELF）

## 3. 可重定位目标文件

![image-20220512200355413](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220512200355413.png)

可重定位目标序列中是分为不同节的序列信息，其中符号表.symtab包含程序中定义和引用的函数和全局变量的信息。

一个目标模块m的符号表包括：

- 由模块m定义并能被其他模块引用的全局符号——**全局符号**
- 由其他模块定义并被模块m引用的全局符号——**外部符号**
- 只被模块m定义和引用的局部符号，对应于带static属性的C函数和全局变量，不能被其他模块引用

带有static的本地变量不会进入栈中，而是在.data(已初始化)或者.bss(Block-Storage-Start 未初始化) 为每个定义分配空间，并在符号表中创建一个唯一的本地符号，两个函数中的static同名变量具有不同的链接器符号表示

## 4. 符号解析

### 链接器如何解析多重定义的全局符号？

编译器向链接器输出的是一组可重定位的目标模块。每个模块定位一组符号，有些是局部的，有些是全局的。如果多个模块定义了同名的全局符号时，编译器会向汇编器输出每个全局符号，分为**强符合和弱符号**，而汇编器将这个信息隐含在目标文件的符号表里。其中，强符号是已初始化的全局变量，未初始化的全局变量是弱符号

- 不允许多个同名的强符号
- 如果有一个强符号和多个弱符号同名，选择强符号
- 如果多个弱符号同名，选择任意一个弱符号

```c++
/* file1.c */
#include <stdio.h>
void f(void);
int x = 15213;	// 强符号，被选择

int main() {
    f();	// 将会调用f函数将x的值改为15212，出乎意料之外
    printf("x = %d\n", x);
    return 0;
}

/* file2.c */
int x;		    // 弱符号
void f(){
    x = 15212;
}
```

#### 一些有用的编译器选项：

- GCC-fno-common	遇到多重定义的全局符号时，触发一个错误
- -Werror    将所有的警告都变成错误

-----------

## 5. 与静态库链接

> 将所有相关的目标模块打包成一个单独的文件，称为静态库。
>
> 其可以作为链接器的输入，当链接器构造一个可执行文件时，只从静态库中复制被应用程序引用的目标模块

静态库的优点：

- 相关的函数可以被编写为单独的目标模块，再封装为静态库
- 当需要某个目标模块时，只需要复制静态库中被程序引用的目标模块，减少了空间浪费

在Linux系统中，静态库为**archive**文件，如libc.a，是一组连接的可重定位目标文件的**集合**，有一个**头部用来表述每个成员目标文件的大小和位置**

```shell
# 使用ar工具创建静态库
ar rcs libtest.a   a.o    b.o 
```

```shell
gcc -static -o prog1c main2.c ./libvector
# 等价于
gcc -static -o prog2c main2.c -L. -lvector
# -static 	链接器应该构建一个完全链接的m可执行目标文件
# -L.  -lvector			链接器应在当前目录下查找一个静态库文件  查找静态库文件为libvector.a
```

Tip:

- 命令行中，gcc后跟的库文件参数用来匹配前面目标模块中未定义的符号，所以不能在目标模块之前，所以，**将库文件放在命令行的末尾！！！**
- 对于库文件需要 进行排序，如果库文件`liba.a`引用了`libb.a`，那么`liba.a`必须在`libb.a`之前，这样可以以b库来匹配a库的引用

## 6. 可执行目标文件

![image-20220513210126088](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220513210126088.png)

进程、虚拟内存、内存映射。。

-------------

## 7. 动态链接共享库

> 共享库是致力于解决静态库缺陷，（如每次都需要将函数复制到程序中，造成内存浪费），在运行和加载中可以加载到任意的内存地址，并和一个在内存中的程序链接起来，这个过程叫**动态链接**

Linux系统下常用`.so`后缀来表示动态库文件，也称为动态目标（shared object），而windows下的动态链接库用`.DLL`表示

对于一个库只有一个`.so`文件，所有引用该库的可执行目标文件共享这个`.so`文件中的代码和数据，而非像静态库那样复制代码到引用它们的可执行文件中，在内存中，一个共享库的`.text`节的一个副本可以被不同正在运行的进程共享

### 在链接时链接共享库

```shell
gcc -shared -fpic -o libvector.so addvec.c multvec.c	# -shared表示生成动态库 -fpic表示生成与位置无关的代码

gcc -o prog2 main.c ./libvector.so
```

生成的为部分链接的可执行文件，其中有对定义在共享库中的例程和数据的未解析的引用。加载时，加载器将部分链接的可执行文件映射到内存，然后调用动态链接器。

动态链接器是一个共享目标`ld-linux.so`，加载器加载和运行这个动态链接器，然后执行以下的重定位完成链接任务：

- 重定位`libc.so`(包含系统启动函数`__libc_start_main`，初始化系统环境，调用用户的`main`函数，处理`main`的返回值，并在需要时将控制返回内核)，的文本和数据到某个内存段
- 重定位`libvector.so`的文本和数据到另一个内存段
- 重定位`prog2`中所有对`libc.so`和`libvector.so`的定义的符号的引用

### 在运行时链接共享库

c语言提供了接口函数来使程序可以动态的在运行时链接共享库`#include <dlfcn.h>`，详见csapp p488

```shell
# 编译一个运行时动态链接的接口程序
gcc -rdynamic -o prog2r dll.c -ldl     # 其中dll.c是包含操作动态链接函数的程序
```

## 8. 位置无关代码

> 可以加载而无需重定位的代码称为**位置无关代码**（Position-Independent Code，PIC）`gcc -fpic`
>
> 无限多个进程可以共享一个共享模块代码段的单一副本，而不需重定位

## 9. 库打桩机制

> library interpositioning，允许你截获对共享库的调用，取而代之执行自己的代码

见csapp p492



