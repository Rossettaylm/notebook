# 存储器结构层次

date：2022年05月07日

---------------------

![image-20220507160737048](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220507160737048.png)

![image-20220507160855340](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220507160855340.png)

其中，IO总线是一个简单的抽象，其基于PCI，即**外围设备互联**总线。

现代系统中，共享的PCI总线已经被PCIe（PCI express）取代，它是一组高速串行、通过开关连接的的点到点链路

CPU通过**内存映射IO**的技术来向IO设备发射命令。在使用内存映射IO的系统中，内存地址有一块地址是为与I/O设备通信而保留的空间。每个这样的地址称为一个**I/O端口**，当一个设备被连接到总线时，它与一个或者多个端口相关联

硬盘与I/O总线通信时，需要将对逻辑块的请求翻译成对底层物理设备的访问。在机械硬盘中，有磁盘控制器，而在固态硬盘中，有闪存翻译层。

#### 不同层次的存储技术的访问时间差异很大，且CPU和主存之间的速度差距在增大

#### 一个编写良好的软件善于展示出良好的局部性

- 时间局部性

被引用过的内存位置可能在**不远的将来**被再多次引用

- 空间局部性

被引用过的内存位置的**附近的内存位置**会被多次引用

-------------------------

**由于硬件的层次结构差异和软件的局部性要求，计算机的存储结构体系架构设计如下所示**

![image-20220507172848204](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220507172848204.png)

对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存

数据总是以块大小作为传送单元（transfer unit）在第k层和k+1层来回复制，而第k层的缓存包含了第k+1层一个子集的副本。

![image-20220507173322351](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220507173322351.png)

一般来说层次越低，传输速度越慢，使用的块就越大，k层是k+1层的缓存

#### 缓存命中

程序需要k+1层的数据时，会先在第k层进行查找，如果找到了就成为缓存命中

#### 缓存不命中

在第k层没有找到所需要的数据块，就需要从k+1层进行复制到k层，如果k层已满，就可能会覆盖现存的一个块，此行为被称为**替换(replacing)**，被覆盖的块称为**牺牲块(victim block)**，决定如何覆盖的是缓存的**替换策略(replacement policy)**

#### 缓存不命中的种类

1. 当k层中为空（冷缓存），为**强制性不命中(compulsory miss)**或者**冷不命中(cold miss)**，只会出现在初始阶段且是短暂事件
2. 当执行从k+1层复制数据到k层时，就需要执行**放置策略(placement policy)**，通常使用的是带有限制性的放置策略，如对块号取模值，如造成了进行放置的k+1层的数据都映射到k层的同一缓存块，就会造成一直缓存不命中，这就是**冲突性不命中(conflict miss)**

3. 每个阶段中访问的缓存块是相对不变的集合，如通过for遍历数组访问的是一块连续区域，这个块的集合称为这个阶段的**工作集(working set)**，当工作集的大小过大，k层中的块无法全部容纳，就会造成**容量不命中(capacity miss)**

#### 缓存管理

每个k层的存储设备都是k+1层的缓存，必须以某种逻辑形式来管理缓存，包括

- 将缓存划分成块
- 在不同的层间传送块
- 判断缓存是否命中（是否需要进行块传送）

例如，编译器管理寄存器文件、操作系统和CPU地址翻译硬件共同管理主存中的数据块

#### 局部性与缓存之间的关系

- 时间局部性好的程序，可以在第一次访问的时候将数据块传送到缓存中，从而后面的每次调用直接使用缓存中的数据

- 空间局部性好的程序，因为块通常包括多个数据对象，所以可以使用同一块中的数据，同样放置了多次的传送

#### 高速缓存的通用性结构

表示地址共有m位，其中t位用来表示标记位，s位用来表示组的索引，一个组包含E个`cache line`，而一个`cache line`包含一个高速缓存块

缓存区域的大小（不包括标记位）为$C = S \times E \times B$，即共有S个组，一个组有E个cache line，一个cache line中高速缓存块的大小为B

当缓存中包含了地址A的副本，就会直接调用而不从低一层中复制。

##### 如何知道缓存中是否包含了地址A处的副本？

<u>标记位用来**定位**到组中的具体一行（类似于哈希），当该行有效位有效且标记位与地址中的标记位相匹配时，组中的一行才包括了这个字。通过地址中的b位块偏移在缓存块中进行具体的数据偏移定位</u>

![image-20220510170330165](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220510170330165.png)

![image-20220510171644267](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220510171644267.png)

#### 高速缓存工作的通用概念

##### 读一个字

CPU执行一条读取内存字w的指令时，需要向L1高速缓存进行请求。而L1高速缓存根据缓存是否命中决定是否要向主存请求包含w字的一个数据块副本。

- 高速缓存确定一个字是否命中，然后抽取出被请求字的过程分为三步：

1. 组选择 —— 地址中的s位组索引
2. 行匹配 —— 确定行中的有效位是1且标记位与地址中的标记位相同 
   - 有效位被设置且标记位相同 ——> 缓存命中 ——> 字抽取
   - 有效位没有设置或者标记位不同 ——> 缓存未命中 ——> 行替换 （从下一层次取出被请求的块，进行放置策略）

3. 字抽取 —— 根据块偏移选择起始字节，将高速缓存看做一个数组，块偏移是数组的起始数组

- 标记位和组索引位连起来唯一的标识了内存中的每个块
- 当E大于1，即一个组中有多行cache line时，多个块会映射到同一个高速缓存组，且此时块由标记位唯一的标识
- 为什么组索引是地址的中间位而不是高位？
  - 如果地址高位是组索引，那么高位地址相同的局部空间会被加载到同一个组中，导致缓存空间的利用率很低

- 如果一个缓存中的同一个缓存行，一直有冲突性缓存不命中，就称之为**抖动**（见p432），需要对程序进行优化

<img src="https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220510200219759.png" alt="image-20220510200219759" style="zoom:150%;" />

缓存中能保存的$2^s$组，根据标志位确认组中的cache line，每个cache line中保存一个有效位，t个标志位，b个偏移位，即对主存进行一个数据块传送时其大小为$2^b$

##### 写一个字

当需要写一个已经命中了的字w时（写命中），在高速缓存更新了w的副本后如何更新底层中w的副本？

- 直写（write through），即立即将w的高速缓存块写回到低一层的缓存中，**会增加总线流量**
- 写回（write back），尽可能的延迟写动作，当替换算法将要驱逐这个更新过的块时，才把它写到紧接着的低一层中。**必须为每个cache line维护一个额外的修改位**

如何处理写不命中？

- 写分配（write-allocate），加载低一层的块到高速缓存中，然后更新这个高速缓存块。每次不命中都需要传送一个数据块（写回通常是写分配）
- 非写分配（not-write-allocate），避开高速缓存，直接将这个字写到低一层中（直写通常是非写分配）

**Tip：通常使用一个写回和写分配的高速缓存模型，来优化软件效率，良好的利用了局部性**

#### 高速缓存的分类

- 直接映射高速缓存——E为1的缓存，即每组只有一个cache line

- 组相联高速缓存 —— $1 < E < C/B$，即每个组中cache line的个数大于1，且保证组的个数大于1
  - 一个组中有多行，且都可以包含与地址相同的标志位，所以需要对其进行遍历，以搜索一个有效的行
  - 当缓存不命中时，需要选择合适的放置策略，如随机选择、LRU（Least-Frequently-Used），当缓存在越底层时，一次不命中的时间开销就会越大

- 全相联高速缓存 —— 包含所有高速缓存行的组，`E = C / B, S = 1`此时不需要组索引，所以地址只由标志位t和块偏移b组成

  - 缺点：需要高速并行的搜索许多相匹配的标志位，所以只适合做小的高速缓存，如虚拟内存中的快表（TLB）

  -----------------

#### 高速缓存层次的解剖

- i-cache：只保存指令的缓存，只读
- d-cache：只保存程序数据的缓存
- unified-cache：统一的高速缓存

![image-20220510204723600](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220510204723600.png)

#### 高速缓存友好的代码

- 对局部变量的反复引用是友好的，存储器层次结构会将它们缓存到寄存器文件中（时间局部性）
- 步长为1的引用模式是好的，因为缓存都是将数据存放为连续的块（空间局部性）

#### 如何编写良好利用局部性的代码？

1. 将注意力集中在内循环上，大部分计算和内存访问都集中在这里
2. 按照对象存储在内存中的顺序，以步长为1来读取数据
3. 一旦从从存储器中读入了一个数据对象，就尽可能的多使用它，从而使得程序中的时间局部性最大