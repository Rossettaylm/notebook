# 1异常控制流

date：2022年5月15日

> 控制转移：从一个指令的地址到下一个指令的地址
> 
> 控制流：控制地址的转移序列叫做处理器的控制流

没有发生异常的控制流是一种“平滑的”序列，每个指令之间地址在内存中是相邻的，由普通的跳转、调用，控制和返回指令控制。

但是，系统必须要对系统状态变化做出反映，现代系统通过**使控制流发生突变**来对这些情况做出反应。这些突变称之为**异常控制流**（Exceptional Control Flow，ECF）。其包括了硬件层、操作系统层、软件层，如操作系统系统中通过上下文切换来切换进程；如应用层进程发送另一个信号到另一个进程。

- ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制

- 应用程序通过`trap`或者`system call`的ECF形式，像操作系统请求服务

- ECF是并发的基本机制，如中断应用程序执行的异常处理程序、在时间上重叠执行的进程和线程、中断应用程序执行的信号处理程序

- C++使用`try-catch`来提供软件异常机制，使程序进行非本地跳转来响应错误情况

## 1. 异常

> 定义：异常（exception）就是控制流中的突变，用来响应处理器状态中的某些变化

![image-20220515193636576](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220515193636576.png)

状态变化称为**事件**，处理器检测到有事件发生，就会通过一张异常表（exception table）的跳转表进行一个间接过程调用（异常），得到一个异常处理程序（exception handler）。异常处理完后，根据异常的类型发生：

1. 处理程序返回到$I_{curr}$，事件发生时正在执行的指令

2. 处理程序返回给$I_{next}$，如没有发生异常将会执行的下一条指令

3. 终止被中断的程序

### 1.1 异常处理

异常分配了一个**非负整数**作为**异常号（exception number）**作为区别异常的类型

系统启动时，操作系统会分配和初始化一张**异常表**

![image-20220515195756082](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220515195756082.png)

异常表的起始地址在**异常表基址寄存器**中，起始地址+偏移，生成异常处理程序的地址

![image-20220515200101658](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220515200101658.png)

异常处理和程序过程调用的区别：

- 异常处理返回地址可以是$I_{curr}$或者$I_{next}$

- 处理器会将一些额外的处理器状态压入栈中

- 控制如果从用户移到内核，项目会被压入内核栈而不是用户栈

- 异常模式运行在**内核模式**，对所有资源有访问权限

### 1.2 异常（中断）的类别

同步中断：**执行当前指令造成了异常**，也叫作故障指令（faulting instruction），**由CPU主动产生的，受CPU控制，是可控的**

* 陷阱（系统调用）
* 故障（如缺页，可恢复的，并且需要重新执行指令）
* 终止（abort）

异步中断：**来自外部I/O设备的信号的硬件中断**。硬件异常处理程序叫做**中断处理程序（interrupt handler）**，**来自外部I/O设备的电信号，不可预测**

* 中断

![image-20220515200447850](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220515200447850.png)

#### 1.2.1 中断

> 外部I/O设备发送了一个信号，来触发中断，异常号标识了引起中断的设备

![image-20220515201038784](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220515201038784.png)

#### 1.2.2 陷阱

> 有意的异常。目的是在用户程序和和系统内核之间提供一个像过程一样的接口，叫做**系统调用**

当程序需要向内核请求服务时，如读取文件（read）、创建新进程（fork），加载一个新程序（execve），终止当前进程（exit）。

使用`syscall n`请求陷阱异常处理程序，并调用适当的内核程序。

![image-20220515212031049](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220515212031049.png)

#### 1.2.3 故障

> 故障由错误情况引起，会被故障处理程序修正。
> 
> 如果能修正：返回$I_{curr}$
> 
> 如果不能修正：调用abort终止故障程序

![image-20220515212233344](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220515212233344.png)

#### 1.2.4 终止

由不可恢复的致命错误造成的结果，通常是一些硬件错误。返回一个abort例程，终止应用程序

-------------------------

#### Linux的故障和终止

- 除法错误（Floating exception）
- 一般保护故障（Segmentation fault），如引用了未定义的虚拟内存地址、试图写一个只读文本
- 缺页，会重新执行产生故障的指令
- 机器检查，导致故障的指令检测到了致命的硬件错误，不返回控制给应用程序

#### Linux系统调用

包括读文件、写文件、创建一个新进程等几百个申请内核服务的都是系统调用。每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表（不是异常表）的偏移量。

通过`syscall`C函数可以调用任何系统调用，C函数包装了系统调用指令。这些都称之为**系统级函数**

系统同时提供了`syscall`陷阱指令来进行系统调用，相应的指令编号和文件描述符等放入寄存器再调用。

![image-20220515215334039](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220515215334039.png)

## 2. 进程

每个程序运行在进程（process）的上下文中（context）中。

**上下文（context）是程序运行所需要的状态组成的。**包括：

- 程序的代码和数据
- 程序的栈
- 通用目的寄存器的内容
- 程序计数器
- 环境变量
- 打开文件描述符的集合

一个进程提供给应用程序的**关键抽象**为：

- 一个**独立的逻辑控制流**，提供一个假象，好像我们的程序独占地使用处理器
- 一个**私有的地址空间**，提供一个假象，好像我们的程序独占地使用内存系统

### 2.1 逻辑控制流

![image-20220515224708005](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220515224708005.png)

执行程序过程中，有一系列PC程序计数器值，这些值对应包含在程序的可执行目标中的指令，或者运行时动态链接到程序的共享对象的指令。这个PC的序列叫做**逻辑控制流**或者**逻辑流**

上图中，每个进程一个逻辑流，每个竖条是一个逻辑流中的一部分

进程之间轮流使用处理器，每个进程执行完它的流的一部分后被抢占（preempted）（暂时挂起）

### 2.2 并发流

当一个逻辑流的执行时间与另一个流重叠，称为**并发流**

进程B在A的**开始和结束之间**开始执行，为并发；进程C开始在B结束之后，故不是并发。

- 多个流并发的执行的现象叫做**并发**，并发与处理器核数以及计算机数都无关，只和程序执行时间有关

- 一个进程和其他进程轮流运行的概念叫做**多任务**

- 一个进程执行它的控制流的一部分每一时间段叫做**时间片**，多任务也叫作**时间分片**

- 两个流<u>并发的运行</u>在不同的核或者计算机上，称为**并行流**，是并发流的一个真子集

### 2.3 私有地址空间

进程为每个程序提供它自己的**私有地址空间**，私有地址空间是一种抽象，仿佛程序独占的使用系统，且此时地址空间中和某个地址相关联的内存字节是不能被其他进程读写的。

不同的私有地址空间虽然相关联的内存内容不同，但是有相同的通用结构，x86-64Linux系统的结构如下：

![image-20220516110851894](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220516110851894.png)

### 2.4 用户模式和内核模式

限制一个应用程序可以执行的指令以及它可以访问的地址空间范围

处理器通过某个控制寄存器中的模式位（model bit）来识别是内核模式还是用户模式

用户模式必须通过系统调用接口才能访问内核代码和数据。进程从用户模式变为内核模式的唯一方法是通过中断、故障或者陷入系统调用这样的异常。

Linux中，可以在/proc文件夹下查看内核数据结构的内容，如`/proc/<process-id>/maps`代表某个特殊进程使用的内存段，/sys文件系统输出关于系统总线和设备的额外低层信息

### 2.5 上下文切换

操作系统内核使用一种称为**上下文切换（context switch）**的较高层形式的异常控制流来**实现多任务。**

当进程运行的某些时刻，内核可以决定**抢占或者重新开始一个之前被抢占**的进程，这种决策叫做**调度（scheduling）**，由内核中的调度器（scheduler）代码进行处理。

调度伴随着上下文切换，上下文切换需要做到的是：

1. 保存当前进程的上下文
2. 恢复某个先前被抢占的进程被保存的上下文
3. 将控制传递给这个新恢复的进程

![image-20220516133620957](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220516133620957.png)

------------------

## 3. 系统调用错误处理

通常将错误检查处理封装为一个函数

------------

## 4. 进程控制

### 4.1 获取进程ID

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```

### 4.2 创建和终止进程

进程的三种状态：

- 运行。在CPU上执行或者处理等待被执行（被内核调度）的状态

- 停止。执行被挂起（suspend），且不会被调度。需要接收到`SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU`等信号时停止，接收到中断信号`SIGCONT`时进程再次开始运行

- 终止。进程永远的停止，包括了
  
  - 收到一个终止信号
  - 从主程序返回
  - 调用了exit函数
  
  ```CPP
  /* main */
  return 0;
  // 等价于
  // void exit(int status);
  exit(0);
  ```

c通过fork函数创建一个子进程，子进程会得到父进程用户虚拟地址空间的副本（但独立），且与父进程打开任何文件描述符相同的副本。

最大的区别在于有不同的PID

- fork函数调用一次，返回两次。一次返回子进程的PID给父进程，一次返回0给子进程

- 父进程和子进程**并发执行**

- 有相同但是独立的地址空间

- 能够共享文件

- 父进程和子进程的执行顺序不一定

![image-20220516140116234](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220516140116234.png)

![image-20220516140247281](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220516140247281.png)

上图中，调用了两次`Fork()`函数，共生成了4个进程，其中每个`printf`函数可以任意次序执行

### 4.3 回收子进程

当一个进程由于某种原因终止后，是处于终止状态，需要**等待父进程将它回收（reaped）**，回收后，子进程的退出状态会传递给父进程。

一个终止了但是没有回收的进程称为**僵尸进程**。

如果父进程终止了，系统会安排**init**进程称为它孤儿进程的养父。init进程的PID为1，由内核创建且不会终止，是所有进程的祖先。

设计程序中，应该记得回收僵尸子进程

使用waitpid函数等待它的子进程终止或者停止

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);  // 如果成功，返回子进程的PID，如果为WNOHANG，返回0，其他错误返回-1
```

### 4.4 让进程休眠

sleep：将一个进程挂起一段指定的时间

pause：让调用函数休眠，知道该进程收到一个信号

### 4.5 加载并运行程序

`int execve(const char *filename, const char *argv[], const char *envp[]);`

execve函数加载并运行可执行目标文件filename，带有参数列表argv和环境变量envp。只有当出现错误时，才会返回到调用程序。

execve调用一次且从不返回，在当前进程的上下文中加载并运行一个新程序，会覆盖当前进程的地址空间但并不创建一个新的进程。

![image-20220516144316588](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220516144316588.png)

![image-20220516144551991](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220516144551991.png)

c语言中通过getenv、setenv、unsetenv来操控环境变量

### 4.6 利用fork和execve运行程序

```c
/* main 详见csapp p524 */
if ((pid = Fork()) == 0) {
    /* Child runs user job */
    if (execve(argv[0], argv, environ) < 0) {
        printf("%s: Command not found.\n", argv[0]);
        exit(0);
    }
}
```

---------

## 5. 信号

> Linux信号允许进程和内核中断其他进程；信号提供了一种机制，通知用户进程发生了这些异常

![image-20220516152009217](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220516152009217.png)

### 5.1 信号术语

- 发送信号。内核通过更新目的进程的上下文中某个状态，发送一个信号给目的进程，有以下两种情况会发送信号
  
  - 内核检测到一个系统事件
  - 一个进程调用了kill函数显示的要求内核传递信号给进程

- 接受信号。当目的进程被内核强迫对信号的发送发生反应时，就接受了信号。进程对接收到的信号有两种处理方式
  
  - 忽略信号
  - 终止进程或者执行**信号处理程序（signal handler）**（用户层函数），处理程序和主程序并发执行，共享同样的全局变量

![image-20220516152940478](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220516152940478.png)

一个发出但是没有被处理的信号称为**待处理信号（pending signal）**，任何时刻，一种信号只能有一个待处理信号，其余的被丢弃。

**信号的阻塞**：某种信号被阻塞后，可以发送但是进程不会进行接收它，直到进程取消对这种信号的阻塞。

内核为每个进程在pending位向量中维护**待处理信号的集合**；在blocked位向量中维护**被阻塞的信号集合**。当信号传送一个k类型的信号，k位会被设置，只要接受了一个k类型的信号，k位会被清除。

### 5.2 发送信号

**进程组**：每个进程都只属于一个进程组；一个子进程和它的父进程同属于一个进程组

```shell
ps -O pgid
```

**使用kill发送信号**

```shell
kill -9 4325    # 发送SIGKILL信号给4325进程
kill -9 -4325    # pid为负数时，代表进程组，会发送信号给进程组的所有信号
```

### 5.3 接收信号

当内核把进程p从内核模式切换到用户模式时，会检查所有未被阻塞的待处理信号合集（pending &~blocked），如果集合为空，则将控制转移到逻辑流的下一条指令$I_{next}$。如果集合非空，内核会选择集合中的信号k并强制进程p接收信号。一旦完成了接受行为，才会转移到$I_{next}$，每个信号都包含了以下几种行为的一种：

- 进程终止
- 进程终止并转储内存
- 进程停止（挂起）并被SIGCONT信号重启
- 进程忽略该信号