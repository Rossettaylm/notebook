# 信息的表示和处理

## 一、信息存储

> 计算机使用8bit即1字节（Byte）作为最小寻址单位，计算机将内存视为一个非常大的字节数组，即虚拟内存。虚拟内存是一个抽象的概念，实际上将DRAM、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

### 1.十六进制表示法

$x = 2^n$的二进制表示1的后面跟n个0，如
$$
8 = 2^3 = 1000
$$
将n表示成$i+4j$的形式，可以快速的得到其十六进制表示，如
$$
x = 2048 = 2^{11} \\
n = 11 = 3+4\times 2 \\
x = 0x2^300 = 0x800
$$
**十进制转为十六进制的方法：辗转取余法**

![image-20220326172737378](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220326172737378.png)

### 2.字数据大小

计算的字长（32位或64位）指明了指针数据的标称大小。<u>即对于一个字长为$w$的机器而言，虚拟地址的范围为$0 \to 2^w-1$</u>

![image-20220326173016722](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220326173016722.png)

#### 对于跨越多字节的程序对象如何寻址？

* 确立对象的地址（一般为连续字节序列的首字节地址）
* 在内存中如何排序这些字节

小端法和大端法：

**最低有效字节在前则为小端法，反之为大端法**，如数据0x01234567

![image-20220326173325532](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220326173325532.png)

### 3.布尔运算

- a & b 按位与
- a | b 按位或

- a ^ b 按位异或

**布尔环**：当考虑长度为w的位向量上的^、&、|运算时，会得到一种不同的数学形式称之为布尔环。

**加法逆元**：对于任何值a来说，对其本身取异或，<u>a ^ a = 0</u>，其中0表示全0的位向量。

**使用位向量表示有限集合**：$[a_{w-1}, \dots, a_1, a_0]$位向量中取$a_i = 1$的下标$i$组成集合。如$[01101001]$，取位为1的下标组成集合为$A = \{0, 3, 5, 6\}$。对于这种表示方法中，布尔运算&和|对应集合的交和并，而^对应集合的补集。

Tips：确定一个位级表达式的方法就是将其转为2进制并进行布尔运算，再转换为十六进制。

![image-20220327150821889](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220327150821889.png)

**练习：**通过位异或进行的交换程序

![image-20220327151646910](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220327151646910.png)

| 步骤   | *x                      | *y                                |
| ------ | ----------------------- | --------------------------------- |
| 初始   | a                       | b                                 |
| 第一步 | a                       | a ^ b                             |
| 第二步 | a ^ (a ^ b)             | a ^ b                             |
| 第三步 | a ^ (a ^ b) = b ^ 0 = b | a ^ (a ^ b) ^ (a ^ b) = a ^ 0 = a |

**掩码运算**：表示从一个字中选出的位的集合，如掩码0xFF，对一个字a进行掩码运算a & 0xFF 表示从a中取出最低有效字节的值，其他位被置为0。

**布尔运算基本规则**：

- & 运算，0置0
- | 运算，1置1
- ^ 运算，0置本身，1置相反
- a & ~b，先对b取反再进行位与，则b 1置0
- a ^ b = $a\hat b | \hat a b$ 

**逻辑运算**：与布尔运算不同，所有非0的参数都表示True，参数0表示False，返回的结果只有1和0；且为**短路运算符**

![image-20220327160307308](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220327160307308.png)

Tips：仅用位级布尔运算和逻辑运算表示x == y，为 ! (x ^ y)，当x的每一位和y相同时，返回0x01

**移位运算**：

![image-20220327160842804](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220327160842804.png)

其中<u>算术右移（最左端补k个最高有效位的值，而不是直接补1！！！）</u>对有符号数运算有很大作用。

c语言中未定义使用那种形式的右移，编译器一般使用算术右移，但是无符号数必须逻辑右移。

与此不同的是，java中用>>表示算术右移，而>>>表示逻辑右移。

Tips：加减法的优先级是比移位运算符优先级高的。

----------------------

## 二、整数表示

计算机如何编码和操作整数？

![image-20220327163217330](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220327163217330.png)

w位二进制数 对应的 无符号整数**具有唯一性**。如 1011 对应的整数为11

#### 补码

- 不对称性

- 最高位为0，和无符号数编码一样
- 最高位为1
  - **最高位的权重为 $-2^{w-1}$**，如$1011 = -8 + 0 + 2 + 1 = -5$，
  - 或者**除最高位代表符号外，按位取反再加1** ，$1011 = 1101 = -5$

一个补码的最小表示为100...00，即除了最高位减去$-2^{w-1}$，其他位不再加一个数；

一个补码的最大表示为011...11，即$\sum_{i=0}^{w-2} 2^i = 2^{w-1} - 1$ 

综上，一个有符号数的表示范围是$-2^{w-1} \to 2^{w-1}-1$，同样具有**唯一性**，满足二进制补码到有符号整数的双射条件，$T2B_w$是$B2T_w$的反函数。

**如何从内存中读取数据转为整数？**

1. 判断是有符号数还是无符号数 		0xE
2. 将十六进制转为二进制            1110
3. 根据有/无符号数规则将二进制转为整数      有符号数：$-2^3 + 2^2 + 2 = -2$，无符号数：$2^3 + 2^2 +2 = 14$

![image-20220327193154398](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220327193154398.png)

上图中，$UMax_w$表示w位的无符号数最大表示范围，$TMin_w$表示补码的最小表示范围，$TMax_w$表示补码的最大表示范围。

**特别的**：全1码表示-1，全0码表示0

C语言中的强制转换如 int b = (int) a 只是将变量的类型改变了，影响了编译器如何看待变量。而**不会改变底层的二进制位数据**

**补码如何转为无符号数？**

![image-20220327200549232](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220327200549232.png)

如一个8位补码表示为 $0xFF$ 的数据，其有符号数为-1，将其转为无符号数，即$-1 + 2^8 = 255 = 0xFF$ 

**无符号数如何转为补码？**

![image-20220327200925437](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220327200925437.png)

#### C语言的有符号数和无符号数转换

- 默认的整数是有符号数

- 当一个运算数是有符号而另一个是无符号时，**C语言会隐式的将有符号参数类型强制转为无符号数**，并假设它们都是非负的。

**注意！！！如果一个有符号负数被转为无符号数进行计算的话，会变成一个很大的正整数！**

#### 扩展一个数字的位表示

![image-20220327202327989](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220327202327989.png)

- **有符号数（且负数）前面添1，无符号数前面添0**

- 先进行位数大小的扩展，再完成有符号数到无符号数的变化；即**位的扩展的优先级比符号转换更高**

#### 截断一个数字的位表示

```c
int x = 53191;
printf("0x%.8x\n", x);  /* 0x0000cfc7 */
short sx = (short) x;  /* 高位直接截断                0xcfc7       -12345 */
int y = sx;            /* 扩展位表示，c为1开头所以补1   0xFFFFcfc7   -12345 */ 
```

-----------

## 三、整数运算

### 1、加法

#### 无符号数的加法——溢出

对于w位的x和y，满足$0 \leq x, y < 2^{w}$，它们的和满足$0 \leq x+y \leq 2^{w+1} - 2$。**存在溢出现象**

对于溢出w位的最高表示范围的数据，采用截断方法，丢弃任何权重大于$2^{w-1}$的位。等价于对$2^w$取模

x = 1001, y = 1100, x+y = 10101 --> 进行截断为0101

![image-20220328122939838](C:\Users\ylm15\AppData\Roaming\Typora\typora-user-images\image-20220328122939838.png)

##### **如何检测发生了溢出？**

![image-20220328123034662](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328123034662.png)

##### 无符号数加法逆元

$$
-^u_wx = 2^w - x
$$

#### 有符号（补码）的加法——溢出

![image-20220328130215737](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328130215737.png)

##### **如何检测补码加法发生了溢出？**

![image-20220328131135276](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328131135276.png)

##### 有符号数（补码）加法逆元

![image-20220328132720320](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328132720320.png)

可以看成 $0 - TMin_4 = 0000 - 1000 = 1000 = TMin_4$

对于补码的非，可以执行**按位取反再加一（包括符号位）**原则，在C语言中，$-x == ~x+1$

------------

### 2、乘法和移位

#### 无符号乘法（直接取模）

![image-20220328133457467](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328133457467.png)

#### 有符号乘法（补码）

![image-20220328133604477](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328133604477.png)

即先当成无符号数进行乘法并取模，再转为补码形式。 

![image-20220328134256588](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328134256588.png)

**Tips**：不管有符号数还是无符号数，计算的过程都是一样的，都是将十进制数相乘再进行截断，得到最后的w位二进制数的解读方式不一样。

#### 乘以2的幂

> 乘法运算指令相当慢，需要10个及以上的时钟周期
>
> 故优化的一个重要方向是用移位和加法运算的组合来代替乘以常数因子的乘法。

乘以一个$2^k$的常数 == 向左移动k位

##### 如何优化乘法运算的性能？将乘法运算转为移位

![image-20220328141607903](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328141607903.png)

$x * 14  = x * 2^3 + x * 2^2 + x * 2 = (x << 3) + (x << 2) + (x << 1)$

$x * 14 = x * 2^{3+1} - x * 2^1 = (x << (3+1)) - (x << 1)$

#### 除以2的幂

> 整数除法要比整数除法更慢——需要30个以上的时钟周期
>
> 故采用右移运算来实现，无符号数采用逻辑右移，补码采用算术右移

整数除法定义：x除以y，如果结果 x / y 是正数，向下取整取$\lfloor x / y \rfloor$，如果 x / y 是负数，向上取整取$\lceil x / y \rceil$

为了满足整数除法的正确性，编译器将除法转换为移位时，会遵守下列规则：

##### 无符号数：x >> k 逻辑右移k位表示$\lfloor x / k \rfloor$

##### 有符号数：( x + (1 << k) - 1 ) >> k 算术右移k位表示$\lceil x / k \rceil$，当调用除法时，编译器会自动转为右移并加上偏置量

Tips：补码为了保证结果的正确舍入，编译器会对原始的x加上一个偏置再进行移位

![image-20220328145140814](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328145140814.png)

------

### 3、总结

整数运算其实是一种模运算形式，w位的数据进行整数乘法得到的数据需要用2w位来表示；计算机一般对超出w位的数据进行截断，此时可能会发生**溢出**现象，表现为：截断后的二进制数据按相应地无符号或者有符号数来解译会得到错误的答案。

位级的各种运算，都有完全一样或者非常类似的位级行为。

使用unsigned类型时，一定要小心，通过位级的分析，当有一个包含无符号数和有符号数的表达式时，会统一转为无符号数进行运算。这就有可能发生错误，如：一个有符号数转为无符号数时会变成很大的整数。

为了提高乘法和除法之间的运算效率，编译器会采用移位的方式进行运算；其中乘法采用左移运算；除法对于有符号数和无符号数分别采用算术右移和逻辑右移；为了满足整数除法的定义（负数结果向上取整），在结果为负数的除法运算中，采用的算术右移还需要加上一个偏移量，由编译器自动完成。



-------------



## 四、浮点数

### 1、二进制小数

![image-20220328155229577](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328155229577.png)

特点：只能够表示那些被写成$x \times 2^y$的数，其他值只能被**近似**的表示，**增加二进制表示的长度可以提高表示的精度。**

### 2、IEEE浮点表示

![image-20220328161829628](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328161829628.png)

**符号S**：决定浮点数的正负

**尾数M**：一个二进制小数

**阶码**：用来对浮点数进行加权

![image-20220328162059857](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328162059857.png)

![image-20220328162202825](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328162202825.png)

### 3、浮点数的舍入方式

IEEE定义了四种不同的舍入方式，默认的方法是找到最近的匹配，其他三种用于计算上界和下界。

![image-20220328163735533](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220328163735533.png)

默认的方法是向偶数舍入，先找到一个最近的匹配值，对于确定两个可能结果中间值时，倾向于向偶数舍入，如1.5和2.5向2舍入。