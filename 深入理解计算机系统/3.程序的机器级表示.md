# 程序的机器级表示

常用指令

```c++
gcc -Og -S main.cpp; // 原始汇编格式 生成汇编文件.s
gcc -Og -c main.cpp; // 生成.o文件

objdump -d proc // 反汇编，查看可执行程序的反汇编代码
```

## 控制

C语言通过**条件码寄存器**描述最近的算术或者逻辑操作的属性，通过检测这些寄存器来执行条件分支指令jump

- CF 进位标志。最高位进位来检测无符号数的溢出
- ZF 零标志。最近的操作得出的结果是0
- SF 符号标志。最近的操作得到的结果是负数
- OF 溢出标志。最近的操作导致一个补码溢出，有符号数的溢出检测



## 过程

过程用一组指定的参数和一个可选的返回值实现了某种功能，即函数。

- 传递控制，P调用Q时，需要将P待执行的下条指令压入栈中，并将PC程序计数器设置为Q的起始地址
- 传递数据 ，P向Q提供一个或多个参数，并返回一个值。当参数大于6个时，多余的参数需要在栈帧中分配空间
- 分配和释放内存，在开始时，为Q分配内存，在返回时，必须释放内存空间

![image-20220402202022264](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220402202022264.png)

x86-64的栈顶是向低地址方向增长的，且寄存器%rsp指向栈顶的指针。通过减小rsp的值来分配内存空间，反之通过增大rsp来释放内存空间。

**栈帧：**当x86-64过程（函数）需要的存储空间大于寄存器所能提供的内存空间，就需要在栈中分配内存空间，这个称为过程（函数）的栈帧。

**参数构造区**：为传入的超出6个的参数分配的栈内存空间

-----------

当**寄存器不足或者必须得到变量的地址**时，局部数据必须放在内存中，包括：

- 寄存器不足够存放所有的本地数据
- 对一个局部变量使用了取址运算符（&），必须为其从产生一个地址
- 某些局部变量是数组或结构，必须通过数组或者结构引用访问到

**被调用者保存寄存器**：当过程P调用过程Q时，过程Q要保存这些寄存器的值，不改变或者将其压入栈中，在返回前从栈中弹出旧值。

**调用者寄存器**：除了栈指针寄存器以及被调用者寄存器，其他寄存器为调用者保存寄存器。过程P在此类寄存器中有局部数据，然后调用过程Q，Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据时P（调用者）的责任。

**递归过程**：每个过程调用在栈中有其自己的私有空间，因此多个未完成调用的局部变量不会相互影响。

**数据对齐原则：**任何K字节的基本对象的地址必须是K的倍数，下图插入了3个字节的空白

![image-20220403235205985](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220403235205985.png)

**gdb的使用**：

![image-20220404001843617](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220404001843617.png)

![image-20220404001914845](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220404001914845.png)

### 缓冲区溢出

原理：分配的缓冲区以及程序保存的局部变量和程序返回地址都保存在栈内存中，如果对超过缓冲区大小的范围进行了数据的存储和读写，将会**把数据或者返回地址给覆盖**，发生意想不到的错误。

![image-20220406110040489](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220406110040489.png)

**如何对抗栈溢出的攻击？**

- 栈随机化：程序开始时，在栈上分配随机0~n个字节空间，程序不使用这段空间，但是它会导致程序每次执行后续的栈位置发生变化

![image-20220406112016873](https://rossetta-typora-imgsubmit.oss-cn-hangzhou.aliyuncs.com/img/image-20220406112016873.png)

栈随机化是**地址空间布局随机化(Address-Space Layout Randomization, ASLR)**技术的一种，ASLR保证每次运行程序时，程序代码、库代码、栈、全局变量、和堆数据，都会被加载到内存的不同区域。

- 栈破坏监测：**栈保护者机制 (stack protector)**可以在局部缓冲区和栈状态之间设置一个金丝雀(canary)值，如果这个值被改写，则程序异常中止。

Tips: char str[N] 在栈中会分配2N个字节的空间

- 限制可执行代码区域