# 类

date：2021年11月20日

> 类的基本思想是**数据抽象（data abstraction）**和**封装（encapsulation）**。
>
> 数据抽象是一种依赖于**接口（interface）**和**实现（implementation）**分离的编程设计计术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。
>
> 封装实现了类的接口和现实的分离。用户只能使用接口（API）而无法访问实现部分。
>
> 类想要实现数据抽象和封装，需要定义一个**抽象数据类型（abstract data type）**。设计者负责考虑类的实现过程，而使用者只需要抽象的思考类型做了什么，无需了解实现细节。

[TOC]



## 一、定义抽象数据类型

设计一个抽象数据类型，需要定义一些操作供用户使用，同时将类的数据成员进行封装。

### 1、设计Sales_data类

一个Sales_data的接口应该包含：

* 一个isbn成员函数，用于返回对象的**ISBN**编号
* 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上
* 一个名为add的函数，执行两个Sales_data对象的加法
* 一个read函数，将数据从istream读入到Sales_data对象中
* 一个print函数，将Sales_data对象的值输出到ostream中

#### this指针

**当我们调用某个成员函数时，实际上是在替某个对象调用它。成员函数通过一个名为`this`的隐式指针访问调用它的那个对象**

```c++
Sales_data book("c++ primer");
book.isbn(); // 实际上，对于成员函数传入了book的地址给this指针
```

#### 常量成员函数 int func() const {};

**const成员函数的作用是修改this指针的类型，保证常量对象能够调用类的成员函数**

`std::string isbn() const { return this->ISBN; }`

默认情况下，`this`的类型是<u>指向类类型非常量版本的常量指针</u>。在Sales_data的成员函数中，`this`的类型是顶层const，`Sales_data *const`，表示`this`指针将一直指向此对象。此时我们不能把`this`绑定到一个常量对象上，即`this`的类型没有底层const属性，`this`本身是一个常量，但是其指向的对象是变量。我们不能一个常量对象上调用普通的成员函数，所以需要把`this`声明为常量！

如果isbn是一个普通函数且this是一个普通指针，我们应该把this声明成`const Sales_data *const`。因为this是一个隐式的变量，因此将const放在参数列表之后表示声明一个**常量成员函数(const member funciton)。**

#### 类作用域和成员函数

* 类本身就是一个作用域。
* 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。成员函数体可以随意使用类中的成员无需在意其出现的次序。

#### 类外定义成员函数

* 类外部定义的成员须包含它所属的类名。

```c++
double Sales_data::avg_price() const {
    ...
}
```



* 返回类型、参数列表和函数名应该和类内部的声明保持一致。

#### 定义一个返回this对象的函数

`return *this;`

### 2、定义类相关的非成员函数

一些辅助函数如add、read、print，属于类接口的组成部分，但不属于类本身，为<u>非成员函数</u>。

应该将非成员函数的声明和类放在同一个头文件中，同时将函数的声明和定义分离开来。

### 3、构造函数

> 类通过一个或几个特殊的成员函数来**控制对象的初始化过程**，这些特殊函数就是构造函数。

* 没有返回类型
* 构造函数参数列表和函数体都可以为空
* 类可以包含多个构造函数，但在参数数量和参数类型上要有所区别
* 构造函数不能声明成const

#### 默认构造函数（default constructor)

默认构造参数无须任何实参，如果没有定义构造函数，编译器会隐式定义一个默认构造函数，又叫**合成的默认构造函数（synthesized default constructor）**。

* 如果存在类内初始值，按其初始化成员
* 否则，默认初始化该成员

**当有多个构造函数时，需要定义自己的默认构造函数。**

#### 定义Sales_data的构造函数

定义几个构造函数：

* 一个空参数列表（默认构造函数），当有多个构造函数时，需要定义自己的默认构造函数

* istream&，从中读取一条交易信息
* 一个const string&，表示ISBN编号；编译器将赋予其他成员默认值
* const string&，表示ISBN编号；一个unsigned，表示售出的图书数量

```cpp
Sales_data() = default;	// 如果编译器不支持类内初始值，需要使用列表初始化来初始每个成员
Sales_data(std::istream &); 
Sales_data(const std::string &s): ISBN(s) {} // 列表初始化
Sales_data(const std::string &s, unsigned n, double p): ISBN(s), units_sold(n), revenue(p*n) {}
```

#### 构造函数初始值列表（constructor initialize list）

> 负责为新创建的对象的一个或几个数据成员赋初始值，紧跟在参数列表之后，以冒号开始，逗号隔开

```cpp
Sales_data(const std::string &s, unsigned n, double p): ISBN(s), units_sold(n), revenue(p*n) {}
```

***Tips:***

初始化的几种方式：

1. 默认初始化（根据类型）
2. 类内初始值初始化（需要编译器支持）
3. 构造函数初始值列表初始化（不在列表内的执行1或者2）

### 4、拷贝、赋值和析构 BIG THREE

> 类需要控制拷贝、赋值和销毁对象时发生的行为，如果我们不主动定义这些操作，编译器将替我们合成它们

----------------------------

## 二、访问控制和封装

#### 1、封装定义

> 通过**访问说明符（access specifiers）**来加强类的封装性
> 一个类可以包含0个或者多个访问说明符，不限制出现次数，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止
>
> public：说明其成员在整个程序内可以被访问，public成员定义类的接口
>
> private：说明其成员可以被类的成员函数所访问，不能使用该类的代码访问，private部分封装了类的实现细节

**struct关键字和class关键字的区别仅在于默认的访问权限，class为private，而struct为public。**

--------------

#### 2、友元

> 类可以允许其他类或者函数访问它的非共有成员，方法是声明有友元。
>
> 如果类想把一个函数作为它的友元，只需要增加一条以friend为关键字的函数声明语句。
>
> 友元的声明**仅仅制定了访问权限**，而非一个通常意义的函数声明。

```c++
class Sales_data {
// 做友元声明，保证非类成员函数可以访问到类内非共有成员
friend Sales_data add(const Sales_data&, const Sales_data&);
friend std::istream &read(std::istream&, Sales_data &);
friend std::ostream &print(std::ostream&, const Sales_data &);
    ...
}
```

**封装有两个重要的优点**

* 确保用户代码不会无意间破坏封装对象的状态
* 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码

---------------

## 三、类的其他特性

### 1、类成员特性

```c++
class Screen {
public:
	typedef std::string::size_type pos; // 用来定义类型的成员必须先定义后使用
    Screen() = default;	// 因为Screen有另一个构造函数，所以默认构造函数必需
    Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) {}
    ...
private:
    pos cursor = 0;	// 未用初始化列表初始化，故隐式的使用类内初始值初始化
    pos height = 0, width = 0;
    std::string contents;
}
```

#### 类的内联函数

* 类内部成员函数是自动inline的；
* 在类的外部使用inline关键字修饰函数的定义`inline void func() {}`

#### 重载成员函数

* 和非成员函数一样，只要**函数之间在参数的数量和/或类型有所区别**就可以重载。

#### 可变数据成员(mutable data member)

> 当希望<u>修改类内的某个数据成员，即使是在一个const成员函数内</u>。可以通过在变量中的声明加入**mutable**关键字来完成。

```c++
class Screen {
public:
    void some_member() const;
private:
    mutable size_t access_ctr;	// 即使在一个const对象内也能被修改
    ...
}

void Screen::some_member() const {
    ++access_ctr;	// 保存一个计数值，用于记录成员函数被调用的次数
}
```

#### 类数据成员的初始值

> 当希望类中某个数据成员开始时总是拥有一个默认初始化的数据，最好的方式是将其默认值声明成一个类内初始值。

**当我们提供一个类内初始值时，必须以符号“=”或者花括号“{}”表示。**

---------------------

### 2、返回*this的成员函数

* 返回值是引用`Screen &func() { return *this; }`，则返回的左值（见函数章），是当前对象本身；
* 返回值是普通`Screen func() { return *this; }`，则返回的是对象的一个副本，对象本身不会被改变；
* 一个const成员函数如果以引用的方式返回*this，那么它的返回类型将是常量引用；
* 可以根据成员函数是否const，来进行**重载**，因为只能在一个常量对象上调用const成员函数，且最好在非常量对象上调用函数的非常量版本；

------------

### 3、类类型

> 即使两个类的成员完全一致，它们也是不同的类型

* 直接把类名作为类型的名字使用，从而直接指向类类型（通常做法）：`Sales_data item;`；
* 把类名跟在关键字class或struct后面：`class Sales_data item;`

两种方法等价。

#### 类的声明

* 前向声明（forward declaration）：`class Screen;`，暂时声明类而不定义，占用一个名字，此时是一个不完全类型（incomplete type）；
* 前向声明应用场景：
  * 定义指向这种类型的指针或引用；
  * 声明以不完全类型作为参数或返回类型的函数。

----------------------

### 4、友元再探

* 可声明的友元包括：其他类、其他类的成员函数。
* 友元函数可以定义在类的内部，这样的函数是隐式内联的。
* 友元关系不存在传递性。

当A类需要用到B类的类私有成员时，一般的设计流程如下：

1. 在A类中先进行类方法的声明，但不能定义它；
2. 在B类中将A类或A类的类方法进行友元声明；
3. 最后回到A类中进行类方法的定义，这样它才能使用B类的私有属性成员。

#### 函数重载和友元

如果一个类想把一组重载函数声明成它的友元，则需要对函数中的每一个**分别声明**。

--------------

## 四、类的作用域

> 每个类有其自己的作用域。
> 在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。
> 对于类类型成员来说，则使用作用域运算符 “::” 访问。

略，见c++ primer p253

----------

## 五、构造函数再探

* 当成员是**const或者引用或者某种未提供默认构造函数的类型**时，需要对该成员进行初始化
* 最好养成构造函数初始值的习惯
* 令构造函数初始值的顺序和成员声明保持一致，且尽量避免用某些成员初始化其他成员

```c++
class ConstRef {
public:
    ConstRef(int ii);
private:
    int i;
    const int ci;
    int &ri;
};

ConstRef::ConstRef(int ii)
{
    i = ii;	// 正确
    ci = ii;	// 错误：不能给const赋值
    ri = i;		// 错误：ri是引用，没有被初始化
}
```

### 1、**委托构造函数（delegating constructor）**

> 一个委托构造函数把自己的初始化过程委托给了类中的其他构造函数

```c++
class Sales_data {
public:
    // 非委托构造函数使用对应的实参初始化成员
    Sales_data(std::string s, unsigned cnt, double price): ISBN(s), units_sold(cnt), revenue(cnt*price) {}
    // 委托构造函数，都委托给另一个构造函数
    Sales_data() : Sales_data("", 0, 0) {}
    Sales_data(std::string s) : Sales_data(s, 0, 0) {}
    Sales_data(std::istream &is) : Sales_data() { read(is, *this); }
}
```

### 2、默认构造函数的作用

**当对象被默认初始化或者值初始化时自动执行默认构造函数。**

如下情况中使用默认初始化：

* 在块作用域内不使用任何初始值定义一个<u>非静态变量</u>
* 一个类本身含有类类型的成员且使用合成的默认构造函数时
* 类类型的成员没有在构造函数初始值列表中显式的初始化时

如下情况使用值初始化：

* 数组初始化的过程中如果我们提供的初始值数量少于数组的大小
* 不使用初始值定义一个<u>局部静态变量</u>时
* 通过书写如T（）的表达式显式的请求初始化时，其中T是类型名

### 3、聚合类

> 聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。需满足如下条件：
>
> * 所有成员都是public
> * 没有定义任何构造函数
> * 没有类内初始值
> * 没有基类，也没有virtual函数

```c++
// 聚合类
struct Data {
    int ival;
    string s;
};
```

用一个花括号括起来的成员初始值列表来初始化聚合类的成员，顺序要一致：

`Data val1 = { 0, "Anna" };`

### 4、字面值常量类

> 数据成员都是字面值类型的聚合类，都是字面值常量类。
>
> 如果一个类不是聚合类，如果符合：
>
> * 数据成员都是字面值类型
> * 类中必须至少含有一个constexpr构造函数
> * 如果一个数据成员含有类内初始值，内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类类型，初始值必须使用成员自己的constexpr构造函数
> * 类必须使用析构函数的默认定义

#### **constexpr构造函数**

* 构造函数不能是const，但是字面值常量类的构造函数可以是且至少有一个是constexpr
* constexpr构造函数可以声明成=default
* constexpr构造函数必须初始化所有数据成员

--------------

## 六、类的静态成员

> 当类需要一些成员与类本身相关，且类生成的每个对象都共用一个此成员，则声明为类静态成员。

### 1、static声明

`static double rate() { return interestRate; }`

* 所有对象共享一个static对象

* 且static对象不包含this指针
* 因为const成员函数是对this声明的，所以static函数不能声明为const

### 2、static使用

* 使用`类名::静态成员`来直接访问静态成员，如`Account::rate()`
* 可以使用类的对象、引用或者指针来访问静态成员
* 类成员函数不用通过作用域运算符`::`就能直接使用静态成员
* 可以用静态成员作为函数的默认实参，而非静态成员不能作为函数实参，因为它的值属于对象的一部分

### 3、static定义

* 可以在类内部或者外部定义
* 在类外定义时不能重复static关键字，static关键字只出现在类内部的声明
* 因为静态成员不属于任何一个对象，所以不能在创建类对象时初始化它，**应该在类的外部定义和初始化每个静态成员**，且其只能被定义一次

```c++
// 类外定义并初始化一个静态成员，其中initRate()是一个private函数
double Account::interestRate = initRate();
```

* <u>一般把静态函数成员的定义与其他非内联函数的定义放在同一个文件中</u>

### 4、static类内初始化

特别地，可以且**只能**为static成员提供**const整数类型**的类内初始值，且要求静态成员必须是字面值常量类型的constexpr `static constexpr int a = 1;`

